#!/usr/bin/env bash
# ABOUTME: Automated deployment script for TAS Capacity Analyzer.
# ABOUTME: Deploys backend and frontend to Cloud Foundry with checkpoint/resume support.

set -Eeuo pipefail

#######################################
# Logging functions
#######################################
log_info() {
    echo -e "\033[0;34m[INFO]\033[0m $*"
}

log_success() {
    echo -e "\033[0;32m[OK]\033[0m   $*"
}

log_warn() {
    echo -e "\033[0;33m[WARN]\033[0m $*"
}

log_error() {
    echo -e "\033[0;31m[ERROR]\033[0m $*" >&2
}

log_debug() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "\033[0;90m[DEBUG]\033[0m $*"
    fi
}

#######################################
# Error handling
#######################################
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 && -n "${CURRENT_PHASE:-}" ]]; then
        log_error "Deployment failed during phase: $CURRENT_PHASE"
        log_info "Re-run the script to resume from this phase"
    fi
}
trap cleanup EXIT

error_handler() {
    local line=$1
    local command=$2
    log_error "Command failed at line $line"
    log_error "Command: $command"
}
trap 'error_handler $LINENO "$BASH_COMMAND"' ERR

#######################################
# Utility functions
#######################################
require_cmd() {
    local cmd="$1"
    local msg="${2:-Required command not found: $cmd}"
    if ! command -v "$cmd" >/dev/null 2>&1; then
        log_error "$msg"
        return 1
    fi
}

#######################################
# Constants
#######################################
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
readonly CONFIG_FILE="$PROJECT_ROOT/config/deploy.conf"
readonly STATE_DIR="$PROJECT_ROOT/.state"
readonly STATE_FILE="$STATE_DIR/deploy-state"

#######################################
# Script options
#######################################
VERBOSE=false
DRY_RUN=false
FRESH=false
SKIP_PREREQS=false
PHASE=""

#######################################
# Current execution state
#######################################
CURRENT_PHASE=""

#######################################
# Configuration loading
#######################################
load_config() {
    # Load from config file if it exists
    if [[ -f "$CONFIG_FILE" ]]; then
        log_info "Loading config from $CONFIG_FILE"
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    else
        log_debug "No config file found at $CONFIG_FILE, using environment variables"
    fi

    # Apply defaults for any unset variables
    : "${CF_ORG:=system}"
    : "${CF_SPACE:=system}"
    : "${BACKEND_APP_NAME:=capacity-backend}"
    : "${FRONTEND_APP_NAME:=capacity-ui}"
    : "${OM_SKIP_SSL_VALIDATION:=false}"

    # Export for child processes (generate-env.sh)
    export OM_TARGET OM_USERNAME OM_PASSWORD OM_SKIP_SSL_VALIDATION
    export OM_CLIENT_ID OM_CLIENT_SECRET OM_PRIVATE_KEY
    export CF_ORG CF_SPACE BACKEND_APP_NAME FRONTEND_APP_NAME
}

#######################################
# State management
#######################################
state_init() {
    mkdir -p "$STATE_DIR"
    if [[ -f "$STATE_FILE" ]]; then
        log_debug "Loading state from $STATE_FILE"
        # shellcheck source=/dev/null
        source "$STATE_FILE"
    fi
}

state_get() {
    local key="$1"
    local var_name="STATE_$key"
    echo "${!var_name:-}"
}

state_set() {
    local key="$1"
    local value="$2"
    local var_name="STATE_$key"

    # Set in memory
    declare -g "$var_name=$value"

    # Persist to file atomically
    if [[ "$DRY_RUN" != "true" ]]; then
        # Atomic write: temp file + mv prevents corruption if interrupted
        local tmp_file
        tmp_file=$(mktemp "${STATE_FILE}.XXXXXX")
        {
            echo "# Auto-generated by scripts/deploy.sh - do not edit manually"
            echo "# Last updated: $(date -Iseconds)"
            for var in $(compgen -v | grep "^STATE_" | grep -v "^STATE_DIR$" | grep -v "^STATE_FILE$"); do
                # Use printf %q for safe quoting of special characters
                printf '%s=%q\n' "$var" "${!var}"
            done
        } > "$tmp_file"
        mv "$tmp_file" "$STATE_FILE"
    fi
}

state_is_complete() {
    local phase="$1"
    [[ "$(state_get "$phase")" == "complete" ]]
}

state_clear() {
    log_info "Clearing deployment state"
    if [[ "$DRY_RUN" != "true" ]]; then
        rm -f "$STATE_FILE"
    fi
    # Clear in-memory state (exclude readonly STATE_DIR and STATE_FILE)
    for var in $(compgen -v | grep "^STATE_" | grep -v "^STATE_DIR$" | grep -v "^STATE_FILE$"); do
        unset "$var"
    done
}

#######################################
# Usage
#######################################
usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Deploy TAS Capacity Analyzer to Cloud Foundry.

Options:
    -h, --help          Show this help message
    -v, --verbose       Enable verbose output
    -n, --dry-run       Show what would be done without executing
    -f, --fresh         Clear state and run from scratch
    --skip-prereqs      Skip prerequisite checks
    --phase=PHASE       Run only specified phase:
                        prereqs, env, backend, frontend, verify

Phases:
    prereqs     Check required tools and connectivity
    env         Generate .env credentials via generate-env.sh
    backend     Deploy backend service to CF
    frontend    Build and deploy frontend to CF
    verify      Verify deployment health

Examples:
    $(basename "$0")                    # Run all phases
    $(basename "$0") --phase=backend    # Run only backend deployment
    $(basename "$0") --fresh            # Start fresh, ignore previous state
    $(basename "$0") --dry-run          # Preview without executing

Configuration:
    Copy config/deploy.conf.example to config/deploy.conf and fill in values.
    Alternatively, set environment variables directly.

EOF
    exit 0
}

#######################################
# Argument parsing
#######################################
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--fresh)
                FRESH=true
                shift
                ;;
            --skip-prereqs)
                SKIP_PREREQS=true
                shift
                ;;
            --phase=*)
                PHASE="${1#*=}"
                shift
                ;;
            --phase)
                PHASE="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                usage
                ;;
            *)
                log_error "Unexpected argument: $1"
                usage
                ;;
        esac
    done

    # Validate phase if specified
    if [[ -n "$PHASE" ]]; then
        case "$PHASE" in
            prereqs|env|backend|frontend|verify)
                ;;
            *)
                log_error "Invalid phase: $PHASE"
                log_error "Valid phases: prereqs, env, backend, frontend, verify"
                exit 1
                ;;
        esac
    fi
}

#######################################
# Main entry point (placeholder)
#######################################
main() {
    parse_args "$@"

    log_info "TAS Capacity Analyzer Deployment Script"
    log_info "Project root: $PROJECT_ROOT"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_warn "Dry-run mode: no changes will be made"
    fi

    load_config

    # Handle --fresh flag
    if [[ "$FRESH" == "true" ]]; then
        state_clear
    fi

    state_init

    if [[ "$VERBOSE" == "true" ]]; then
        log_debug "Verbose mode enabled"
        log_debug "CF_ORG=$CF_ORG"
        log_debug "CF_SPACE=$CF_SPACE"
        log_debug "BACKEND_APP_NAME=$BACKEND_APP_NAME"
        log_debug "FRONTEND_APP_NAME=$FRONTEND_APP_NAME"
    fi

    if [[ -n "$PHASE" ]]; then
        log_info "Running single phase: $PHASE"
    fi

    log_info "State management ready (phase implementation pending)"
}

main "$@"

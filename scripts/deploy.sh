#!/usr/bin/env bash
# ABOUTME: Automated deployment script for TAS Capacity Analyzer.
# ABOUTME: Deploys backend and frontend to Cloud Foundry with checkpoint/resume support.

set -Eeuo pipefail

#######################################
# Logging functions
#######################################
log_info() {
    echo -e "\033[0;34m[INFO]\033[0m $*"
}

log_success() {
    echo -e "\033[0;32m[OK]\033[0m   $*"
}

log_warn() {
    echo -e "\033[0;33m[WARN]\033[0m $*"
}

log_error() {
    echo -e "\033[0;31m[ERROR]\033[0m $*" >&2
}

log_debug() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "\033[0;90m[DEBUG]\033[0m $*"
    fi
}

#######################################
# Error handling
#######################################
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 && -n "${CURRENT_PHASE:-}" ]]; then
        log_error "Deployment failed during phase: $CURRENT_PHASE"
        log_info "Re-run the script to resume from this phase"
    fi
}
trap cleanup EXIT

error_handler() {
    local line=$1
    local command=$2
    log_error "Command failed at line $line"
    log_error "Command: $command"
}
trap 'error_handler $LINENO "$BASH_COMMAND"' ERR

#######################################
# Utility functions
#######################################
require_cmd() {
    local cmd="$1"
    local msg="${2:-Required command not found: $cmd}"
    if ! command -v "$cmd" >/dev/null 2>&1; then
        log_error "$msg"
        return 1
    fi
}

#######################################
# Constants
#######################################
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
readonly CONFIG_FILE="$PROJECT_ROOT/config/deploy.conf"
readonly STATE_DIR="$PROJECT_ROOT/.state"
readonly STATE_FILE="$STATE_DIR/deploy-state"

#######################################
# Script options
#######################################
VERBOSE=false
DRY_RUN=false
FRESH=false
SKIP_PREREQS=false
PHASE=""

#######################################
# Current execution state
#######################################
CURRENT_PHASE=""

#######################################
# Configuration loading
#######################################
load_config() {
    # Load from config file if it exists
    if [[ -f "$CONFIG_FILE" ]]; then
        log_info "Loading config from $CONFIG_FILE"
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    else
        log_debug "No config file found at $CONFIG_FILE, using environment variables"
    fi

    # Apply defaults for any unset variables
    : "${CF_ORG:=system}"
    : "${CF_SPACE:=system}"
    : "${BACKEND_APP_NAME:=capacity-backend}"
    : "${FRONTEND_APP_NAME:=capacity-ui}"
    : "${OM_SKIP_SSL_VALIDATION:=false}"

    # Export for child processes (generate-env.sh)
    export OM_TARGET OM_USERNAME OM_PASSWORD OM_SKIP_SSL_VALIDATION
    export OM_CLIENT_ID OM_CLIENT_SECRET OM_PRIVATE_KEY
    export CF_ORG CF_SPACE BACKEND_APP_NAME FRONTEND_APP_NAME
}

#######################################
# State management
#######################################
state_init() {
    mkdir -p "$STATE_DIR"
    if [[ -f "$STATE_FILE" ]]; then
        log_debug "Loading state from $STATE_FILE"
        # shellcheck source=/dev/null
        source "$STATE_FILE"
    fi
}

state_get() {
    local key="$1"
    local var_name="STATE_$key"
    echo "${!var_name:-}"
}

state_set() {
    local key="$1"
    local value="$2"
    local var_name="STATE_$key"

    # Set in memory
    declare -g "$var_name=$value"

    # Persist to file atomically
    if [[ "$DRY_RUN" != "true" ]]; then
        # Atomic write: temp file + mv prevents corruption if interrupted
        local tmp_file
        tmp_file=$(mktemp "${STATE_FILE}.XXXXXX")
        {
            echo "# Auto-generated by scripts/deploy.sh - do not edit manually"
            echo "# Last updated: $(date -Iseconds)"
            for var in $(compgen -v | grep "^STATE_" | grep -v "^STATE_DIR$" | grep -v "^STATE_FILE$" || true); do
                # Use printf %q for safe quoting of special characters
                printf '%s=%q\n' "$var" "${!var}"
            done
        } > "$tmp_file"
        mv "$tmp_file" "$STATE_FILE"
    fi
}

state_is_complete() {
    local phase="$1"
    [[ "$(state_get "$phase")" == "complete" ]]
}

state_clear() {
    log_info "Clearing deployment state"
    if [[ "$DRY_RUN" != "true" ]]; then
        rm -f "$STATE_FILE"
    fi
    # Clear in-memory state (exclude readonly STATE_DIR and STATE_FILE)
    for var in $(compgen -v | grep "^STATE_" | grep -v "^STATE_DIR$" | grep -v "^STATE_FILE$" || true); do
        unset "$var"
    done
}

#######################################
# Usage
#######################################
usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Deploy TAS Capacity Analyzer to Cloud Foundry.

Options:
    -h, --help          Show this help message
    -v, --verbose       Enable verbose output
    -n, --dry-run       Show what would be done without executing
    -f, --fresh         Clear state and run from scratch
    --skip-prereqs      Skip prerequisite checks
    --phase=PHASE       Run only specified phase:
                        prereqs, env, backend, frontend, verify

Phases:
    prereqs     Check required tools and connectivity
    env         Generate .env credentials via generate-env.sh
    backend     Deploy backend service to CF
    frontend    Build and deploy frontend to CF
    verify      Verify deployment health

Examples:
    $(basename "$0")                    # Run all phases
    $(basename "$0") --phase=backend    # Run only backend deployment
    $(basename "$0") --fresh            # Start fresh, ignore previous state
    $(basename "$0") --dry-run          # Preview without executing

Configuration:
    Copy config/deploy.conf.example to config/deploy.conf and fill in values.
    Alternatively, set environment variables directly.

EOF
    exit 0
}

#######################################
# Argument parsing
#######################################
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--fresh)
                FRESH=true
                shift
                ;;
            --skip-prereqs)
                SKIP_PREREQS=true
                shift
                ;;
            --phase=*)
                PHASE="${1#*=}"
                shift
                ;;
            --phase)
                PHASE="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                usage
                ;;
            *)
                log_error "Unexpected argument: $1"
                usage
                ;;
        esac
    done

    # Validate phase if specified
    if [[ -n "$PHASE" ]]; then
        case "$PHASE" in
            prereqs|env|backend|frontend|verify)
                ;;
            *)
                log_error "Invalid phase: $PHASE"
                log_error "Valid phases: prereqs, env, backend, frontend, verify"
                exit 1
                ;;
        esac
    fi
}

#######################################
# Phase 1: Prerequisites
#######################################
phase_prereqs() {
    CURRENT_PHASE="prereqs"
    log_info "Phase 1: Checking prerequisites"

    if state_is_complete "PREREQS" && [[ "$FRESH" != "true" ]]; then
        log_success "Phase 1 already complete (skipping)"
        return 0
    fi

    local failed=false

    # Check cf CLI
    if require_cmd cf "cf CLI not found. Install from https://github.com/cloudfoundry/cli"; then
        local cf_version
        cf_version=$(cf version | head -1 | awk '{print $3}' | cut -d'+' -f1)
        local cf_major
        cf_major=$(echo "$cf_version" | cut -d. -f1)
        if [[ "$cf_major" -ge 8 ]]; then
            log_success "cf CLI v$cf_version"
        else
            log_error "cf CLI version $cf_version is too old (need v8+)"
            failed=true
        fi
    else
        failed=true
    fi

    # Check om CLI
    if require_cmd om "om CLI not found. Install from https://github.com/pivotal-cf/om"; then
        local om_version
        om_version=$(om version 2>/dev/null || echo "unknown")
        log_success "om CLI $om_version"
    else
        failed=true
    fi

    # Check node
    if require_cmd node "node not found. Install Node.js 18+ from https://nodejs.org"; then
        local node_version
        node_version=$(node --version | sed 's/v//')
        local node_major
        node_major=$(echo "$node_version" | cut -d. -f1)
        if [[ "$node_major" -ge 18 ]]; then
            log_success "node v$node_version"
        else
            log_error "node version $node_version is too old (need v18+)"
            failed=true
        fi
    else
        failed=true
    fi

    # Check npm
    if require_cmd npm "npm not found"; then
        local npm_version
        npm_version=$(npm --version)
        log_success "npm v$npm_version"
    else
        failed=true
    fi

    # Check jq
    if require_cmd jq "jq not found. Install from https://stedolan.github.io/jq/"; then
        local jq_version
        jq_version=$(jq --version)
        log_success "jq $jq_version"
    else
        failed=true
    fi

    # Check CF login
    log_debug "Checking CF login status..."
    if cf target >/dev/null 2>&1; then
        local cf_user
        cf_user=$(cf target | grep -i "user:" | awk '{print $2}')
        log_success "CF logged in as $cf_user"
    else
        log_error "Not logged in to CF. Run: cf login -a https://api.sys.your-domain.com"
        failed=true
    fi

    # Check OM connectivity (only if OM_TARGET is set)
    if [[ -n "${OM_TARGET:-}" ]]; then
        log_debug "Checking Ops Manager connectivity..."
        if om curl -s -p /api/v0/info >/dev/null 2>&1; then
            log_success "Ops Manager reachable at $OM_TARGET"
        else
            log_warn "Cannot reach Ops Manager at $OM_TARGET (may need credentials)"
        fi
    else
        log_debug "OM_TARGET not set, skipping Ops Manager check"
    fi

    if [[ "$failed" == "true" ]]; then
        log_error "Prerequisite checks failed"
        return 1
    fi

    state_set "PREREQS" "complete"
    log_success "Phase 1 complete"
}

#######################################
# Main entry point
#######################################
main() {
    parse_args "$@"

    log_info "TAS Capacity Analyzer Deployment Script"
    log_info "Project root: $PROJECT_ROOT"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_warn "Dry-run mode: no changes will be made"
    fi

    load_config

    # Handle --fresh flag
    if [[ "$FRESH" == "true" ]]; then
        state_clear
    fi

    state_init

    if [[ "$VERBOSE" == "true" ]]; then
        log_debug "Verbose mode enabled"
        log_debug "CF_ORG=$CF_ORG"
        log_debug "CF_SPACE=$CF_SPACE"
        log_debug "BACKEND_APP_NAME=$BACKEND_APP_NAME"
        log_debug "FRONTEND_APP_NAME=$FRONTEND_APP_NAME"
    fi

    # Run phases
    if [[ -n "$PHASE" ]]; then
        # Single phase mode
        case "$PHASE" in
            prereqs)  phase_prereqs ;;
            env)      log_info "Phase env not yet implemented" ;;
            backend)  log_info "Phase backend not yet implemented" ;;
            frontend) log_info "Phase frontend not yet implemented" ;;
            verify)   log_info "Phase verify not yet implemented" ;;
        esac
    else
        # Run all phases
        if [[ "$SKIP_PREREQS" != "true" ]]; then
            phase_prereqs
        fi
        log_info "Remaining phases not yet implemented"
    fi
}

main "$@"

#!/usr/bin/env bash
# ABOUTME: Automated deployment script for TAS Capacity Analyzer.
# ABOUTME: Deploys backend and frontend to Cloud Foundry with checkpoint/resume support.

set -Eeuo pipefail

#######################################
# Logging functions
#######################################
log_info() {
    echo -e "\033[0;34m[INFO]\033[0m $*"
}

log_success() {
    echo -e "\033[0;32m[OK]\033[0m   $*"
}

log_warn() {
    echo -e "\033[0;33m[WARN]\033[0m $*"
}

log_error() {
    echo -e "\033[0;31m[ERROR]\033[0m $*" >&2
}

log_debug() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "\033[0;90m[DEBUG]\033[0m $*"
    fi
}

#######################################
# Error handling
#######################################
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 && -n "${CURRENT_PHASE:-}" ]]; then
        log_error "Deployment failed during phase: $CURRENT_PHASE"
        log_info "Re-run the script to resume from this phase"
    fi
}
trap cleanup EXIT

error_handler() {
    local line=$1
    local command=$2
    log_error "Command failed at line $line"
    log_error "Command: $command"
}
trap 'error_handler $LINENO "$BASH_COMMAND"' ERR

#######################################
# Utility functions
#######################################
require_cmd() {
    local cmd="$1"
    local msg="${2:-Required command not found: $cmd}"
    if ! command -v "$cmd" >/dev/null 2>&1; then
        log_error "$msg"
        return 1
    fi
}

#######################################
# Constants
#######################################
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
readonly CONFIG_FILE="$PROJECT_ROOT/config/deploy.conf"
readonly STATE_DIR="$PROJECT_ROOT/.state"
readonly STATE_FILE="$STATE_DIR/deploy-state"

#######################################
# Script options
#######################################
VERBOSE=false
DRY_RUN=false
FRESH=false
SKIP_PREREQS=false
PHASE=""

#######################################
# Current execution state
#######################################
CURRENT_PHASE=""

#######################################
# Configuration loading
#######################################
load_config() {
    # Load from config file if it exists
    if [[ -f "$CONFIG_FILE" ]]; then
        log_info "Loading config from $CONFIG_FILE"
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    else
        log_debug "No config file found at $CONFIG_FILE, using environment variables"
    fi

    # Apply defaults for any unset variables
    : "${CF_ORG:=system}"
    : "${CF_SPACE:=system}"
    : "${BACKEND_APP_NAME:=capacity-backend}"
    : "${FRONTEND_APP_NAME:=capacity-ui}"
    : "${OM_SKIP_SSL_VALIDATION:=false}"

    # Export for child processes (generate-env.sh)
    export OM_TARGET OM_USERNAME OM_PASSWORD OM_SKIP_SSL_VALIDATION
    export OM_CLIENT_ID OM_CLIENT_SECRET OM_PRIVATE_KEY
    export CF_ORG CF_SPACE BACKEND_APP_NAME FRONTEND_APP_NAME
}

#######################################
# State management
#######################################
state_init() {
    mkdir -p "$STATE_DIR"
    if [[ -f "$STATE_FILE" ]]; then
        log_debug "Loading state from $STATE_FILE"
        # shellcheck source=/dev/null
        source "$STATE_FILE"
    fi
}

state_get() {
    local key="$1"
    local var_name="STATE_$key"
    echo "${!var_name:-}"
}

state_set() {
    local key="$1"
    local value="$2"
    local var_name="STATE_$key"

    # Set in memory
    declare -g "$var_name=$value"

    # Persist to file atomically
    if [[ "$DRY_RUN" != "true" ]]; then
        # Atomic write: temp file + mv prevents corruption if interrupted
        local tmp_file
        tmp_file=$(mktemp "${STATE_FILE}.XXXXXX")
        {
            echo "# Auto-generated by scripts/deploy.sh - do not edit manually"
            echo "# Last updated: $(date -Iseconds)"
            for var in $(compgen -v | grep "^STATE_" | grep -v "^STATE_DIR$" | grep -v "^STATE_FILE$" || true); do
                # Use printf %q for safe quoting of special characters
                printf '%s=%q\n' "$var" "${!var}"
            done
        } > "$tmp_file"
        mv "$tmp_file" "$STATE_FILE"
    fi
}

state_is_complete() {
    local phase="$1"
    [[ "$(state_get "$phase")" == "complete" ]]
}

state_clear() {
    log_info "Clearing deployment state"
    if [[ "$DRY_RUN" != "true" ]]; then
        rm -f "$STATE_FILE"
    fi
    # Clear in-memory state (exclude readonly STATE_DIR and STATE_FILE)
    for var in $(compgen -v | grep "^STATE_" | grep -v "^STATE_DIR$" | grep -v "^STATE_FILE$" || true); do
        unset "$var"
    done
}

#######################################
# Usage
#######################################
usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Deploy TAS Capacity Analyzer to Cloud Foundry.

Options:
    -h, --help          Show this help message
    -v, --verbose       Enable verbose output
    -n, --dry-run       Show what would be done without executing
    -f, --fresh         Clear state and run from scratch
    --skip-prereqs      Skip prerequisite checks
    --phase=PHASE       Run only specified phase:
                        prereqs, env, backend, frontend, verify

Phases:
    prereqs     Check required tools and connectivity
    env         Generate .env credentials via generate-env.sh
    backend     Deploy backend service to CF
    frontend    Build and deploy frontend to CF
    verify      Verify deployment health

Examples:
    $(basename "$0")                    # Run all phases
    $(basename "$0") --phase=backend    # Run only backend deployment
    $(basename "$0") --fresh            # Start fresh, ignore previous state
    $(basename "$0") --dry-run          # Preview without executing

Configuration:
    Copy config/deploy.conf.example to config/deploy.conf and fill in values.
    Alternatively, set environment variables directly.

EOF
    exit 0
}

#######################################
# Argument parsing
#######################################
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--fresh)
                FRESH=true
                shift
                ;;
            --skip-prereqs)
                SKIP_PREREQS=true
                shift
                ;;
            --phase=*)
                PHASE="${1#*=}"
                shift
                ;;
            --phase)
                PHASE="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                usage
                ;;
            *)
                log_error "Unexpected argument: $1"
                usage
                ;;
        esac
    done

    # Validate phase if specified
    if [[ -n "$PHASE" ]]; then
        case "$PHASE" in
            prereqs|env|backend|frontend|verify)
                ;;
            *)
                log_error "Invalid phase: $PHASE"
                log_error "Valid phases: prereqs, env, backend, frontend, verify"
                exit 1
                ;;
        esac
    fi
}

#######################################
# Phase 1: Prerequisites
#######################################
phase_prereqs() {
    CURRENT_PHASE="prereqs"
    log_info "Phase 1: Checking prerequisites"

    if state_is_complete "PREREQS" && [[ "$FRESH" != "true" ]]; then
        log_success "Phase 1 already complete (skipping)"
        return 0
    fi

    local failed=false

    # Check cf CLI
    if require_cmd cf "cf CLI not found. Install from https://github.com/cloudfoundry/cli"; then
        local cf_version
        cf_version=$(cf version | head -1 | awk '{print $3}' | cut -d'+' -f1)
        local cf_major
        cf_major=$(echo "$cf_version" | cut -d. -f1)
        if [[ "$cf_major" -ge 8 ]]; then
            log_success "cf CLI v$cf_version"
        else
            log_error "cf CLI version $cf_version is too old (need v8+)"
            failed=true
        fi
    else
        failed=true
    fi

    # Check om CLI
    if require_cmd om "om CLI not found. Install from https://github.com/pivotal-cf/om"; then
        local om_version
        om_version=$(om version 2>/dev/null || echo "unknown")
        log_success "om CLI $om_version"
    else
        failed=true
    fi

    # Check node
    if require_cmd node "node not found. Install Node.js 18+ from https://nodejs.org"; then
        local node_version
        node_version=$(node --version | sed 's/v//')
        local node_major
        node_major=$(echo "$node_version" | cut -d. -f1)
        if [[ "$node_major" -ge 18 ]]; then
            log_success "node v$node_version"
        else
            log_error "node version $node_version is too old (need v18+)"
            failed=true
        fi
    else
        failed=true
    fi

    # Check npm
    if require_cmd npm "npm not found"; then
        local npm_version
        npm_version=$(npm --version)
        log_success "npm v$npm_version"
    else
        failed=true
    fi

    # Check jq
    if require_cmd jq "jq not found. Install from https://stedolan.github.io/jq/"; then
        local jq_version
        jq_version=$(jq --version)
        log_success "jq $jq_version"
    else
        failed=true
    fi

    # Check CF login
    log_debug "Checking CF login status..."
    if cf target >/dev/null 2>&1; then
        local cf_user
        cf_user=$(cf target | grep -i "user:" | awk '{print $2}')
        log_success "CF logged in as $cf_user"
    else
        log_error "Not logged in to CF. Run: cf login -a https://api.sys.your-domain.com"
        failed=true
    fi

    # Check OM connectivity (only if OM_TARGET is set)
    if [[ -n "${OM_TARGET:-}" ]]; then
        log_debug "Checking Ops Manager connectivity..."
        if om curl -s -p /api/v0/info >/dev/null 2>&1; then
            log_success "Ops Manager reachable at $OM_TARGET"
        else
            log_warn "Cannot reach Ops Manager at $OM_TARGET (may need credentials)"
        fi
    else
        log_debug "OM_TARGET not set, skipping Ops Manager check"
    fi

    if [[ "$failed" == "true" ]]; then
        log_error "Prerequisite checks failed"
        return 1
    fi

    state_set "PREREQS" "complete"
    log_success "Phase 1 complete"
}

#######################################
# Phase 2: Environment
#######################################
phase_env() {
    CURRENT_PHASE="env"
    log_info "Phase 2: Generating environment"

    if state_is_complete "ENV" && [[ "$FRESH" != "true" ]]; then
        log_success "Phase 2 already complete (skipping)"
        return 0
    fi

    local env_file="$PROJECT_ROOT/.env"
    local generate_script="$PROJECT_ROOT/generate-env.sh"

    # Check if .env already exists with required variables
    if [[ -f "$env_file" ]]; then
        log_debug "Checking existing .env file..."
        local has_required=true
        for var in BOSH_ENVIRONMENT CF_API_URL CF_USERNAME CF_PASSWORD; do
            if ! grep -q "^$var=" "$env_file" 2>/dev/null; then
                log_debug "Missing $var in .env"
                has_required=false
                break
            fi
        done
        if [[ "$has_required" == "true" ]]; then
            log_success ".env already exists with required variables"
            state_set "ENV" "complete"
            log_success "Phase 2 complete"
            return 0
        fi
    fi

    # Need to generate .env
    if [[ ! -f "$generate_script" ]]; then
        log_error "generate-env.sh not found at $generate_script"
        return 1
    fi

    # Check required Ops Manager credentials
    if [[ -z "${OM_TARGET:-}" ]]; then
        log_error "OM_TARGET is required to generate credentials"
        log_error "Set OM_TARGET in config/deploy.conf or environment"
        return 1
    fi

    local has_auth=false
    if [[ -n "${OM_USERNAME:-}" && -n "${OM_PASSWORD:-}" ]]; then
        has_auth=true
    fi
    if [[ -n "${OM_CLIENT_ID:-}" && -n "${OM_CLIENT_SECRET:-}" ]]; then
        has_auth=true
    fi
    if [[ "$has_auth" == "false" ]]; then
        log_error "Missing Ops Manager authentication"
        log_error "Set OM_USERNAME/OM_PASSWORD or OM_CLIENT_ID/OM_CLIENT_SECRET"
        return 1
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY-RUN] Would run: $generate_script"
        state_set "ENV" "complete"
        log_success "Phase 2 complete (dry-run)"
        return 0
    fi

    log_info "Running generate-env.sh..."
    if ! "$generate_script"; then
        log_error "generate-env.sh failed"
        return 1
    fi

    # Verify .env was created
    if [[ ! -f "$env_file" ]]; then
        log_error ".env file was not created"
        return 1
    fi

    log_success ".env generated with credentials"
    state_set "ENV" "complete"
    log_success "Phase 2 complete"
}

#######################################
# Phase 3: Backend
#######################################
phase_backend() {
    CURRENT_PHASE="backend"
    log_info "Phase 3: Deploying backend"

    if state_is_complete "BACKEND" && [[ "$FRESH" != "true" ]]; then
        log_success "Phase 3 already complete (skipping)"
        return 0
    fi

    local env_file="$PROJECT_ROOT/.env"
    local backend_dir="$PROJECT_ROOT/backend"

    # Source .env for credentials
    if [[ -f "$env_file" ]]; then
        log_debug "Loading credentials from .env"
        set +u  # Temporarily allow unset variables during source
        # shellcheck source=/dev/null
        source "$env_file"
        set -u
    else
        log_error ".env file not found. Run phase 'env' first."
        return 1
    fi

    # Verify backend directory exists
    if [[ ! -d "$backend_dir" ]]; then
        log_error "Backend directory not found: $backend_dir"
        return 1
    fi

    # Target CF org/space
    log_info "Targeting CF org/space: $CF_ORG/$CF_SPACE"
    if [[ "$DRY_RUN" != "true" ]]; then
        cf target -o "$CF_ORG" -s "$CF_SPACE"
    fi

    # Push backend app
    log_info "Pushing $BACKEND_APP_NAME..."
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY-RUN] Would run: (cd $backend_dir && cf push $BACKEND_APP_NAME)"
    else
        (cd "$backend_dir" && cf push "$BACKEND_APP_NAME")
    fi

    # Set environment variables
    log_info "Setting environment variables..."
    local env_vars=(
        "CF_API_URL=${CF_API_URL:-}"
        "CF_USERNAME=${CF_USERNAME:-}"
        "CF_PASSWORD=${CF_PASSWORD:-}"
        "BOSH_ENVIRONMENT=${BOSH_ENVIRONMENT:-}"
        "BOSH_CLIENT=${BOSH_CLIENT:-}"
        "BOSH_CLIENT_SECRET=${BOSH_CLIENT_SECRET:-}"
        "BOSH_DEPLOYMENT=${BOSH_DEPLOYMENT:-}"
    )

    # Add BOSH_CA_CERT if set (handle multiline)
    if [[ -n "${BOSH_CA_CERT:-}" ]]; then
        env_vars+=("BOSH_CA_CERT=${BOSH_CA_CERT}")
    fi

    # Add BOSH_ALL_PROXY if set
    if [[ -n "${BOSH_ALL_PROXY:-}" ]]; then
        env_vars+=("BOSH_ALL_PROXY=${BOSH_ALL_PROXY}")
    fi

    # Add vSphere vars if set
    if [[ -n "${VSPHERE_HOST:-}" ]]; then
        env_vars+=(
            "VSPHERE_HOST=${VSPHERE_HOST}"
            "VSPHERE_DATACENTER=${VSPHERE_DATACENTER:-}"
            "VSPHERE_USERNAME=${VSPHERE_USERNAME:-}"
            "VSPHERE_PASSWORD=${VSPHERE_PASSWORD:-}"
        )
    fi

    for env_var in "${env_vars[@]}"; do
        local key="${env_var%%=*}"
        local value="${env_var#*=}"
        if [[ -n "$value" ]]; then
            log_debug "Setting $key"
            if [[ "$DRY_RUN" != "true" ]]; then
                cf set-env "$BACKEND_APP_NAME" "$key" "$value" >/dev/null
            fi
        fi
    done

    # Restage to apply env vars
    log_info "Restaging $BACKEND_APP_NAME..."
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY-RUN] Would run: cf restage $BACKEND_APP_NAME"
    else
        cf restage "$BACKEND_APP_NAME"
    fi

    # Get backend URL
    local backend_url
    if [[ "$DRY_RUN" == "true" ]]; then
        backend_url="$BACKEND_APP_NAME.apps.example.com"
    else
        backend_url=$(cf app "$BACKEND_APP_NAME" | grep -E "^routes:" | awk '{print $2}')
        if [[ -z "$backend_url" ]]; then
            log_error "Failed to extract backend URL from cf app output"
            return 1
        fi
    fi
    state_set "BACKEND_URL" "$backend_url"

    log_success "Backend running at $backend_url"
    state_set "BACKEND" "complete"
    log_success "Phase 3 complete"
}

#######################################
# Main entry point
#######################################
main() {
    parse_args "$@"

    log_info "TAS Capacity Analyzer Deployment Script"
    log_info "Project root: $PROJECT_ROOT"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_warn "Dry-run mode: no changes will be made"
    fi

    load_config

    # Handle --fresh flag
    if [[ "$FRESH" == "true" ]]; then
        state_clear
    fi

    state_init

    if [[ "$VERBOSE" == "true" ]]; then
        log_debug "Verbose mode enabled"
        log_debug "CF_ORG=$CF_ORG"
        log_debug "CF_SPACE=$CF_SPACE"
        log_debug "BACKEND_APP_NAME=$BACKEND_APP_NAME"
        log_debug "FRONTEND_APP_NAME=$FRONTEND_APP_NAME"
    fi

    # Run phases
    if [[ -n "$PHASE" ]]; then
        # Single phase mode
        case "$PHASE" in
            prereqs)  phase_prereqs ;;
            env)      phase_env ;;
            backend)  phase_backend ;;
            frontend) log_info "Phase frontend not yet implemented" ;;
            verify)   log_info "Phase verify not yet implemented" ;;
        esac
    else
        # Run all phases
        if [[ "$SKIP_PREREQS" != "true" ]]; then
            phase_prereqs
        fi
        phase_env
        phase_backend
        log_info "Remaining phases not yet implemented"
    fi
}

main "$@"
